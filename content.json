{"meta":{"title":"SnowBall Blog","subtitle":"","description":"","author":"ssun4098","url":"http://ssun4098.github.io","root":"/"},"pages":[{"title":"categories","date":"2024-05-15T06:49:34.000Z","updated":"2024-05-15T06:50:28.294Z","comments":true,"path":"categories/index.html","permalink":"http://ssun4098.github.io/categories/index.html","excerpt":"","text":""},{"title":"tages","date":"2024-05-15T07:12:37.000Z","updated":"2024-05-15T07:12:37.597Z","comments":true,"path":"tages/index.html","permalink":"http://ssun4098.github.io/tages/index.html","excerpt":"","text":""}],"posts":[{"title":"CommonJS와 ES modules","slug":"ECMAModules","date":"2024-05-18T04:41:22.000Z","updated":"2024-05-19T12:37:19.292Z","comments":true,"path":"2024/05/18/ECMAModules/","permalink":"http://ssun4098.github.io/2024/05/18/ECMAModules/","excerpt":"","text":"CommonJS 2009년에 자바스크립트 모듈을 만들기 위한 법칙으로 서버사이드 모듈을 만들고 불러오기 위해 개발 require, exports를 사용하여 모듈을 다룬다. babel에서는 pacakge.json에 type:module을 선언해야 사용할 수 있다. 모듈 내보내기(exports) 1234567function add(a, b) &#123; return a + b&#125;module.exports = add 모듈 가져오기123const add = require(&#x27;./파일명&#x27;) ES6 import와 export로 모듈을 내보내거나 가져올 수 있다. 브라우저에서 사용할려면 script 태그에 type&#x3D;”module” 어트리뷰트를 추가햐애 한다. 또한 JS 파일의 확장자를 mjs로 설정하는 것을 권장하고 있다. 번외1: ReactJS에서 NPM 패키지 모듈 사용NPM에서는 CommonJS를 기본 모듈로 채택한다는 것은 require, module.exports를 사용한다. 그런데 React, Vue 같은 프론트 엔드 개발을 할 떄NPM 패키지 모듈을 불러오기 위해 ES6문법을 사용하는데 왜 문제가 발생하지 않을까? 그건 Babel 등의 컴파일러가 import, export 등의 코드를CommonJS 기반의 코드로 변환해주기 때문이다. 그러고 나면 Webpack에 의해 JS 모듈들의 번들링이 가능해진다. 번외2: CommonJS와 ESM 모두 대응하는 라이브러리 개발 ## 왜 두 방식을 지원해야하는가? - 브라우저 환경에서는 페이지 렌더링을 빠르게 하는 것이 중요한데, 이떄 JS는 로딩되어 실행되는 동안 페이지 렌더링을 중단시키는 리소스 중 하나이다. - 따라서 JS 번들의 사이즈를 줄여서 렌더링이 중단되는 시간을 최소화 하는 것이 중요한데 이를 Tree-shaking이다. - Tree-Shaking이란 필요하느 않는 코드와 사용되지 않는 코드를 삭제하여 JS 번들의 크기를 가볍게 만드는 것을 말한다. - CJS는 Tree-Shaking이 이렵고 ESM은 쉽다. 왜 CJS는 Tree-Shaking이 어렵나? - CJS는 빌드 타임에 정적 분석이 아닌 런타임 시점에서 모듈 관계를 파악할 수 있다. => 페이지 랜더링이 늦어짐 - ESM은 정적인 구조로 모듈끼리 의존하도록 강제하고 import path에 동적인 값을 사용할 수 없으며 export는 항상 최상위 스코프에서만 사용하는 등 Tree-Shaking이 더 쉽다. 파일 구별법(CJS인지 MJS인지) - .js: package.json의 type 필드의 값이 commonjs이면 .js 파일은 CJS로 해석, module이면 ESM으로 해석(기본값은 commonjs) - .cjs: 항상 CJS로 해석 - .mjs: 항상 MJS로 해석 엔트리 포인트 지정 - main 필드는 패캐지의 진입점을 말한다. 예를들어 사용자가 apple 이라는 패키지를 설치하고 require('apple')로 모듈을 호출하면 main으로 지정한 모듈의 exports 객체가 반환된다. Subpath exports 지원 기존에는 filesystem 기반으로 패키지 내부의 임의의 JS파일에 접근할 수 있었고 filesystem 상의 위치와 import path를 다르게 둘 수 없었다. 하지만 exports field를 사용하여 subpath exports를 사용하면 명시된 subpath 외에는 사용할 수 없고, filesystem 상의 위치와 import path를 다르게 지정할 수 있다. conditional exports exports field에서는 똑같은 import path에 대해 특정 조건에 따라 다른 모듈을 제공할 수 있다. 참고사이트[CommonJS vs ES6]https://it-eldorado.tistory.com/92 [대응하는 라이브러리 개발하기: exports field]https://toss.tech/article/commonjs-esm-exports-field","categories":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/tags/javascript/"}]},{"title":"REPL과 module.exports","slug":"repl","date":"2024-05-16T13:59:07.000Z","updated":"2024-05-16T14:32:48.107Z","comments":true,"path":"2024/05/16/repl/","permalink":"http://ssun4098.github.io/2024/05/16/repl/","excerpt":"","text":"REPL 콘솔 중 하나 R(Read), E(Evaluate), P(Print), L(Loop) &#x3D;&gt; 읽고 평가하고 출력하고 반복한다. 윈도에서는 명령 프롬프트, 맥이나 리눅스에서는 터미널에 node 입력 node JS파일명 하면 js파일을 실행 모듈 모듈: 특정한 기능을 하는 함수나 변수들의 집합 모듈로 만들면 여러 프로그램에서 재사용 가능 파일의 끝에서 module.exports로 모듈을 생성 다른 파일에서 require로 그 모듈의 내용을 가져올 수 있음 mod.js123456789const mod1 = &#x27;홀수입니다.&#x27;;const mod2 = &#x27;짝수입니다.&#x27;;// 모듈 지정module.exports = &#123; mod1, mod2&#125; main.js12345// 모듈 사용, require는 node에서 제공const &#123;mod1, mod2&#125; = require(&#x27;/mod.js&#x27;)console.log(mod1);console.log(mod2); module.exports와 exports아래와 같은 관계를 가지고 있다.module.exports &#x3D;&#x3D;&#x3D; exports &#x3D;&#x3D;&#x3D; {} 만약 module.exports &#x3D; function () 이런 방법으로 하나만을 넣어주면module.exports !&#x3D;&#x3D; exports &#x3D;&#x3D;&#x3D; {} 이렇게 되어 복잡하게 되니 만약 1개만을 넣고 싶으면module.exports &#x3D; function() 여러개 넣고 싶으면module.exports &#x3D; {} 이런 식으로 자신만의 컨벤션을 정하자 this노드에서 this는 주의할 점이 있다. 최상위 스코프의 this는 module.exports를 가리킴 그 외에는 브라우저와 동일 함수 선언문 내부의 this는 global 객체를 가리킴 require require가 제일 위에 올 필요는 없음, import는 제일 위에 있어야함 require.cache에 한 번 require한 모듈에 대한 캐쉬 정보가 들어 있음, 두번째 읽을 때는 캐쉬를 읽음 require.main은 노드 실행 시 첫 모듈을 가리킴 순환참조 서로가 서로를 참조하는 순환참조가 발생하는 경우 노드에서 자동으로 객체를 빈 객체로 바꿔준다.","categories":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/tags/javascript/"}]},{"title":"NULL 병합과 옵셔널 체이닝","slug":"체이닝","date":"2024-05-15T06:06:33.000Z","updated":"2024-05-15T06:18:35.321Z","comments":true,"path":"2024/05/15/체이닝/","permalink":"http://ssun4098.github.io/2024/05/15/%EC%B2%B4%EC%9D%B4%EB%8B%9D/","excerpt":"","text":"널 병합널 병합 연산자는 주로 || 연산자 대용으로 사용되며, falsy 값(0, ‘’, false, NaN, null, undefined) 중 null과 undefined만 따로 구분한다.옵셔널 체이닝 연산자는 null이나 undefined의 속성을 조회하는 경우 에러가 발생하는 경우를 막는다.(Cannot read properties of null) 12345678910111213141516171819202122232425const a = 0;const b = a || 3; // || 연산자는 falsy 값이면 뒤로 넘어감console.log(b) // 3const c = 0;const d = c ?? 3; // ?? 연산자는 null과 undefined일 때만 뒤로 넘어감console.log(d); // 0;const e = null;const f = e ?? 3;console.log(f); // 3const g = undefined;const h = g ?? 3;console.log(h); // 3// 객체가 null일 경우console.log(c?.d)// 배열이 null일 경우c?.[0]//이런 식으로 사용result = c?.[0] ?? 123","categories":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/tags/javascript/"}]},{"title":"Map,Set,WeakMap,WeakSet","slug":"Map-Set-WeakMap-WeakSet","date":"2024-05-15T05:08:11.000Z","updated":"2024-05-15T06:54:46.786Z","comments":true,"path":"2024/05/15/Map-Set-WeakMap-WeakSet/","permalink":"http://ssun4098.github.io/2024/05/15/Map-Set-WeakMap-WeakSet/","excerpt":"","text":"Map 일반 객체에서 지원해주지 않는 size, forEach 등 사용할 수 있음 순서를 보장한다. 1234567891011121314151617181920// Map 생성const m = new Map();// 키 값에 문자열이 아닌 값도 사용할 수 있다.m.set(&#x27;a&#x27;, &#x27;b&#x27;);m.set(1, &#x27;b&#x27;);// 객체 또한 사용가능, 객체를 Key로 사용할 경우 참조값 고려 필요const key = &#123;&#125;;m.set(key, &#x27;b&#x27;);// Size로 속성 개수 조회console.log(m.size);// forEach 사용가능m.forEach((v, k) =&gt; &#123; console.log(v, k)&#125;) WeakMapJS에서는 도달할 수 없는 또는 추후 사용하지 않을 객체를 가비지 컬렉션에서 삭제한다. 1234567let post = &#123; title: &#x27;Hello&#x27;&#125;// 참조가 null이 되어 위의 데이터에 더 이상 접근할 수 없게 된다.post = null;// 객체가 메모리에서 삭제된다. 자료구조를 구성하는 요소는 자신이 속한 자료구조가 메모리에 남아있는 동안 대개 도달 가능한 값으로 취급되어 메모리에서 삭제되지 않는다.자료구조만이 아니라 객체의 프로퍼티나 배열의 요소, 맵이나 셋을 구성하는 요소들이 해당한다. 123456789101112let post = &#123; title: &#x27;Hello&#x27;&#125;let array = [post];post = null;// 배열에 값이 남아 있음을 확인할 수 있다.console.log(array); 위크맵을 사용할 경우 키로 쓰인 객체가 가비지 컬렉션의 대상이 된다. 12345678910111213141516171819let wm = new WeakMap();let post = &#123; title: &#x27;Hello&#x27;&#125;// 객체 키wm.put(post, &quot;By&quot;);// 문자열은 키로 사용할 수 없다.wm.put(&#x27;key&#x27;, &#x27;Not&#x27;);// 참조를 nullpost = null;// 객체가 사라짐을 확인할 수 있다.console.log(wm); 어디서 사용하는가?데이터 추가 해당 객체를 건들지 않고 추가적으로 데이터를 추가하고 싶다면 사용 캐싱 여러번 메서드를 호출하여 계산하는 대신 저장된 값을 사용하는 경우 해당 객체가 사라질 경우 Map에서 지워주는 로직을 작성할 필요가 없다. Set 중복을 허용하지 않음(자료형은 달라도 된다.) 기존 배열에서 중복을 삭제하고 싶을 경우 사용 12345678910const s = new Set();s.add(1);s.add(&#x27;1&#x27;);s.add(1);const arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];// arr에서 중복제거const set = new Set(arr);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/tags/javascript/"}]}],"categories":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/tags/javascript/"}]}