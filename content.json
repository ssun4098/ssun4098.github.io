{"meta":{"title":"SnowBall Blog","subtitle":"","description":"","author":"ssun4098","url":"http://ssun4098.github.io","root":"/"},"pages":[{"title":"categories","date":"2024-05-15T06:49:34.000Z","updated":"2024-05-15T06:50:28.294Z","comments":true,"path":"categories/index.html","permalink":"http://ssun4098.github.io/categories/index.html","excerpt":"","text":""},{"title":"tages","date":"2024-05-15T07:12:37.000Z","updated":"2024-05-15T07:12:37.597Z","comments":true,"path":"tages/index.html","permalink":"http://ssun4098.github.io/tages/index.html","excerpt":"","text":""}],"posts":[{"title":"REPL과 module.exports","slug":"repl","date":"2024-05-16T13:59:07.000Z","updated":"2024-05-16T14:32:48.107Z","comments":true,"path":"2024/05/16/repl/","permalink":"http://ssun4098.github.io/2024/05/16/repl/","excerpt":"","text":"REPL 콘솔 중 하나 R(Read), E(Evaluate), P(Print), L(Loop) &#x3D;&gt; 읽고 평가하고 출력하고 반복한다. 윈도에서는 명령 프롬프트, 맥이나 리눅스에서는 터미널에 node 입력 node JS파일명 하면 js파일을 실행 모듈 모듈: 특정한 기능을 하는 함수나 변수들의 집합 모듈로 만들면 여러 프로그램에서 재사용 가능 파일의 끝에서 module.exports로 모듈을 생성 다른 파일에서 require로 그 모듈의 내용을 가져올 수 있음 mod.js123456789const mod1 = &#x27;홀수입니다.&#x27;;const mod2 = &#x27;짝수입니다.&#x27;;// 모듈 지정module.exports = &#123; mod1, mod2&#125; main.js12345// 모듈 사용, require는 node에서 제공const &#123;mod1, mod2&#125; = require(&#x27;/mod.js&#x27;)console.log(mod1);console.log(mod2); module.exports와 exports아래와 같은 관계를 가지고 있다.module.exports &#x3D;&#x3D;&#x3D; exports &#x3D;&#x3D;&#x3D; {} 만약 module.exports &#x3D; function () 이런 방법으로 하나만을 넣어주면module.exports !&#x3D;&#x3D; exports &#x3D;&#x3D;&#x3D; {} 이렇게 되어 복잡하게 되니 만약 1개만을 넣고 싶으면module.exports &#x3D; function() 여러개 넣고 싶으면module.exports &#x3D; {} 이런 식으로 자신만의 컨벤션을 정하자 this노드에서 this는 주의할 점이 있다. 최상위 스코프의 this는 module.exports를 가리킴 그 외에는 브라우저와 동일 함수 선언문 내부의 this는 global 객체를 가리킴 require require가 제일 위에 올 필요는 없음, import는 제일 위에 있어야함 require.cache에 한 번 require한 모듈에 대한 캐쉬 정보가 들어 있음, 두번째 읽을 때는 캐쉬를 읽음 require.main은 노드 실행 시 첫 모듈을 가리킴 순환참조 서로가 서로를 참조하는 순환참조가 발생하는 경우 노드에서 자동으로 객체를 빈 객체로 바꿔준다.","categories":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/tags/javascript/"}]},{"title":"NULL 병합과 옵셔널 체이닝","slug":"체이닝","date":"2024-05-15T06:06:33.000Z","updated":"2024-05-15T06:18:35.321Z","comments":true,"path":"2024/05/15/체이닝/","permalink":"http://ssun4098.github.io/2024/05/15/%EC%B2%B4%EC%9D%B4%EB%8B%9D/","excerpt":"","text":"널 병합널 병합 연산자는 주로 || 연산자 대용으로 사용되며, falsy 값(0, ‘’, false, NaN, null, undefined) 중 null과 undefined만 따로 구분한다.옵셔널 체이닝 연산자는 null이나 undefined의 속성을 조회하는 경우 에러가 발생하는 경우를 막는다.(Cannot read properties of null) 12345678910111213141516171819202122232425const a = 0;const b = a || 3; // || 연산자는 falsy 값이면 뒤로 넘어감console.log(b) // 3const c = 0;const d = c ?? 3; // ?? 연산자는 null과 undefined일 때만 뒤로 넘어감console.log(d); // 0;const e = null;const f = e ?? 3;console.log(f); // 3const g = undefined;const h = g ?? 3;console.log(h); // 3// 객체가 null일 경우console.log(c?.d)// 배열이 null일 경우c?.[0]//이런 식으로 사용result = c?.[0] ?? 123","categories":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/tags/javascript/"}]},{"title":"Map,Set,WeakMap,WeakSet","slug":"Map-Set-WeakMap-WeakSet","date":"2024-05-15T05:08:11.000Z","updated":"2024-05-15T06:54:46.786Z","comments":true,"path":"2024/05/15/Map-Set-WeakMap-WeakSet/","permalink":"http://ssun4098.github.io/2024/05/15/Map-Set-WeakMap-WeakSet/","excerpt":"","text":"Map 일반 객체에서 지원해주지 않는 size, forEach 등 사용할 수 있음 순서를 보장한다. 1234567891011121314151617181920// Map 생성const m = new Map();// 키 값에 문자열이 아닌 값도 사용할 수 있다.m.set(&#x27;a&#x27;, &#x27;b&#x27;);m.set(1, &#x27;b&#x27;);// 객체 또한 사용가능, 객체를 Key로 사용할 경우 참조값 고려 필요const key = &#123;&#125;;m.set(key, &#x27;b&#x27;);// Size로 속성 개수 조회console.log(m.size);// forEach 사용가능m.forEach((v, k) =&gt; &#123; console.log(v, k)&#125;) WeakMapJS에서는 도달할 수 없는 또는 추후 사용하지 않을 객체를 가비지 컬렉션에서 삭제한다. 1234567let post = &#123; title: &#x27;Hello&#x27;&#125;// 참조가 null이 되어 위의 데이터에 더 이상 접근할 수 없게 된다.post = null;// 객체가 메모리에서 삭제된다. 자료구조를 구성하는 요소는 자신이 속한 자료구조가 메모리에 남아있는 동안 대개 도달 가능한 값으로 취급되어 메모리에서 삭제되지 않는다.자료구조만이 아니라 객체의 프로퍼티나 배열의 요소, 맵이나 셋을 구성하는 요소들이 해당한다. 123456789101112let post = &#123; title: &#x27;Hello&#x27;&#125;let array = [post];post = null;// 배열에 값이 남아 있음을 확인할 수 있다.console.log(array); 위크맵을 사용할 경우 키로 쓰인 객체가 가비지 컬렉션의 대상이 된다. 12345678910111213141516171819let wm = new WeakMap();let post = &#123; title: &#x27;Hello&#x27;&#125;// 객체 키wm.put(post, &quot;By&quot;);// 문자열은 키로 사용할 수 없다.wm.put(&#x27;key&#x27;, &#x27;Not&#x27;);// 참조를 nullpost = null;// 객체가 사라짐을 확인할 수 있다.console.log(wm); 어디서 사용하는가?데이터 추가 해당 객체를 건들지 않고 추가적으로 데이터를 추가하고 싶다면 사용 캐싱 여러번 메서드를 호출하여 계산하는 대신 저장된 값을 사용하는 경우 해당 객체가 사라질 경우 Map에서 지워주는 로직을 작성할 필요가 없다. Set 중복을 허용하지 않음(자료형은 달라도 된다.) 기존 배열에서 중복을 삭제하고 싶을 경우 사용 12345678910const s = new Set();s.add(1);s.add(&#x27;1&#x27;);s.add(1);const arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];// arr에서 중복제거const set = new Set(arr);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/tags/javascript/"}]}],"categories":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://ssun4098.github.io/tags/javascript/"}]}